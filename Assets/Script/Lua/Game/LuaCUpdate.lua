---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2018/3/1 15:15
---
FileMode_CreateNew = 1;
FileMode_Write = 2;
FileMode_Open = 3;

FileAccess_Read = 1;
FileAccess_Write = 2;
FileAccess_ReadWrite = 3;

--更新方式
EnumUpdateType_Package      = 0; --打包文件更新
EnumUpdateType_SingleFile   = 1; --单个文件更新

LuaCUpdate = {};
this = LuaCUpdate;

local m_fCalcSpeedInterval = 1.0;   --计算下载速度的时间间隔
local m_nLastDownLoadSize = 0;
local m_fLastTime = 0;

local m_languageDic = {};   --热更新的语言国际化配置文件
local m_updateUrl = "";     --更新地址
local m_nCurVer = 1;        --当前版本号
local m_nCurPkgVer = 1;     --当前打包版本号
local m_nToVer = 1;         --最新的版本号
local m_nToPkgVer = 1;      --最新的打包版本号
local m_www = nil;
local m_nVerAfterCurUpdate = 0;     --当前更新后升级到的版本号
local m_downLoadList = {};          --单个文件更新，下载文件列表
local m_dowmCompleteFileList = {};  --下载完成单个文件列表
local m_nCurDownLoadedSize = 0;     --当前已下载的文件内容大小
local m_nDownloadingFileSize = 0;   --下载中的文件，已下载的字节数
local m_nTotalDownloadSize = 0;     --更新内容大小
local m_bDownloadException = false; --下载是否出现异常
local m_arrUpdateType = {};         --所有版本的更新方式列表
local m_bShowUpdatePrompt = true;   --是否显示更新提示
local m_httpDownLoad = nil;         --下载压缩包用的异步加载程序，可以实现断点续传功能
local m_bShowUpdatePanel = true;


function LuaCUpdate.Init()
    this.LoadConfig();
    this.CheckUpdate();
end
function LuaCUpdate.LoadConfig()
    --加载语言配置
    m_languageDic = {};
    local xmlAsset = LoadXmlData("config/language/update");
    if (xmlAsset ~= nil) then
        for i, xml in ipairs(xmlAsset.ChildNodes) do
            local id = tostring(xml.Attributes["id"]);
            local content = tostring(xml.Attributes["str"]);
            m_languageDic[id] = content;
        end
    end

    --加载更新配置文件
    local xmlAsset = LoadXmlData("config/updateConfig");
    if (xmlAsset ~= nil) then
        for i, xml in ipairs(xmlAsset.ChildNodes) do
            if(xml.Name == "url") then
                m_updateUrl = xml.InnerText;
            elseif(xml.Name == "ver") then
                m_nCurVer = tonumber(xml.InnerText);
            end
        end
    end
end

--获得语言文字
function LuaCUpdate.GetLanguageText(key)
    local str = m_languageDic[key];
    if(str == nil) then
        str = "";
    end
    return str;
end

--检测更新
function LuaCUpdate.CheckUpdate()
    this.ReadLocalData();       --读取本地数据
    this.StartRequestVerInfo(); --请求版本号数据
end

--读取本地数据
function LuaCUpdate.ReadLocalData()
    --读取本地版本号数据
    local fileName = UnityEngine.Application.persistentDataPath .. "/.ver";
    if(CLuaFunction.FileExists(fileName)) then
        local str = CLuaFunction.FileReadAllText(fileName);

        local arrStr = LuaCommonMethod.Split(str, "|");
        m_nCurVer = tonumber(arrStr[1]);       --总版本号
        m_nCurPkgVer = tonumber(arrStr[2]);    --打包版本号
    end
end

function LuaCUpdate.StartRequestVerInfo()
    coroutine.start(LuaCUpdate.OnRequestVer);
end

function LuaCUpdate.OnRequestVer()
    local url = "http://" .. m_updateUrl .. "/upgrade/ver.txt?p=" .. math.random(1, 100000000);
    m_www = UnityEngine.WWW(url);
    coroutine.www(m_www);
    if(m_www.error == nil) then
        --解析版本数据
        local str = CLuaFunction.ConvertBytesToString(m_www.bytes);
        local arrStr = LuaCommonMethod.Split(str, "\n");
        for i, strVerInfo in ipairs(arrStr) do
            if(string.find(strVerInfo,"pkgVer:") == 1) then
                local length = string.len("pkgVer:");
                m_nToPkgVer = string.sub(strVerInfo, length + 1, string.len(strVerInfo));
            elseif(string.find(strVerInfo,"ver:") == 1) then
                local length = string.len("ver:");
                local num = string.len(strVerInfo);
                m_nToVer = tonumber(string.sub(strVerInfo, length + 1, string.len(strVerInfo)));
            end
        end
    else
        log("request ver data error:" .. m_www.error);
        LuaCUIUpdateConfirm.ShowConfirm(this.GetLanguageText("Update_RequestVerFail"), "", this.StartRequestVerInfo, UnityEngine.Application.Quit);
    end

    if (m_nCurVer ~= m_nToVer) then --版本号不一致
        if(m_bShowUpdatePanel) then  --显示更新界面
            require "UI/LuaCUIUpdate";
            LuaCUIUpdate.ShowUI();
            LuaGame.AddPerFrameFunc("LuaCUpdate.Update", LuaCUpdate.Update);
            m_bShowUpdatePanel = false;
        end

        --读取本地更新进度数据
        local fileName = this.ProgressDataUrl();
        if (CLuaFunction.FileExists(fileName)) then
            local str = CLuaFunction.FileReadAllText(fileName);
            local arrStr = LuaCommonMethod.Split(str, "\n");
            local strInfo = arrStr[1];
            local arrInfo = LuaCommonMethod.Split(strInfo, ",");
            local nToVer = tonumber(arrInfo[1]);
            if (m_nToVer == nToVer) then
                m_nCurDownLoadedSize = tonumber(arrInfo[2]);

                for i, strComFileName in ipairs(arrStr) do
                    table.insert(m_dowmCompleteFileList, strComFileName);
                end
            else
                CLuaFunction.DeleteFile(fileName);
            end
        end
        this.RequestUpdateTypeSize();
    else
        this.Finish();
    end
end

function LuaCUpdate.RequestUpdateTypeSize()
    coroutine.start(LuaCUpdate.OnRequestUpdateTypeSize);
end
function LuaCUpdate.OnRequestUpdateTypeSize()
    local url = "http://" .. m_updateUrl .. "/upgrade/size.txt?p=" .. math.random(1, 100000000);
    log("请求更新方式:" .. url);
    m_www = UnityEngine.WWW(url);
    coroutine.www(m_www);

    if(m_www.error == nil) then
        --解析数据
        local str = CLuaFunction.ConvertBytesToString(m_www.bytes);
        local arrStr = LuaCommonMethod.Split(str, "|");
        local arrType = LuaCommonMethod.Split(arrStr[1], ".");
        local arrSize = LuaCommonMethod.Split(arrStr[2], ".");
        m_nTotalDownloadSize = tonumber(arrSize[m_nCurVer]);
        m_arrUpdateType = {};
        for i, nType in ipairs(arrType) do
            m_arrUpdateType[i] = tonumber(nType);
        end
    else
        log("请求更新方式出错:" .. m_www.error .. ":" .. m_www.url);
        LuaCUIUpdateConfirm.ShowConfirm(this.GetLanguageText("Update_RequestUpdateDataFail"), "", this.RequestUpdateTypeSize, Application.Quit);
    end
    coroutine.step();
    local type = m_arrUpdateType[m_nCurVer];
    if (m_bShowUpdatePrompt)
    then --是否需要显示更新提示
        local strTips = this.GetLanguageText("Update_NewVer");
        strTips = (strTips .. ("\n" .. this.GetLanguageText("Update_UpdateSize")));
        if ((m_nTotalDownloadSize / 1024 / 1024) > 1) then
            strTips = strTips .. string.format("%0.2f", (m_nTotalDownloadSize / 1024 / 1024)) .. "M";
        else
            strTips = strTips .. string.format("%0.2f", (m_nTotalDownloadSize / 1024)) .. "KB";
        end
        local strAdvise = this.GetLanguageText("Update_AdviseUseWifi");
        if (type == EnumUpdateType_Package) then --压缩包更新
            LuaCUIUpdateConfirm.ShowConfirm(strTips, strAdvise, this.RequestUpdatePkgFile, UnityEngine.Application.Quit);
        else
            LuaCUIUpdateConfirm.ShowConfirm(strTips, strAdvise, this.RequestDownLoadList, UnityEngine.Application.Quit);
        end
        m_bShowUpdatePrompt = false;
    else
        if (type == EnumUpdateType_Package) then --压缩包更新
            this.RequestUpdatePkgFile();
        else
            this.RequestDownLoadList();
        end
    end
end

--请求更新包文件数据
function LuaCUpdate.RequestUpdatePkgFile()
    if(m_httpDownLoad == nil) then
        m_httpDownLoad = HttpDownLoad.New();
    end
    --下载进度回调函数
    --m_httpDownLoad:SetDownloadProgressCallBack(this.OnDownloadPkgFileProgress);

    --下载异常，在线程中调用此函数不能直接调用Unity的东西，故用bool值标记，在下一帧进行相关Unity处理
    m_httpDownLoad:SetDownloadExceptionCallBack(this.LoadException);

    --开始下载
    local url = "http://" .. m_updateUrl .. "/upgrade/package/package" .. m_nCurPkgVer .. "/pkg.bytes?p=" .. math.random(1, 100000000);
    local strTempFileUrl = UnityEngine.Application.persistentDataPath .. "/tempFile.bytes";
    m_httpDownLoad:DownLoad(url, strTempFileUrl);
end

function LuaCUpdate.LoadException()
    m_bDownloadException = true;
end

--下载更新包进度更新
function LuaCUpdate.OnDownloadPkgFileProgress(bytes)
    m_nDownloadingFileSize = bytes;    --刷新已下载文件大小
end

--下载更新包失败
function LuaCUpdate.OnDownloadPkgFileError(bytes)
    LuaCUIUpdateConfirm.ShowConfirm(this.GetLanguageText("Update_downLoadPkgFileFail"), "", this.RequestUpdatePkgFile, UnityEngine.Application.Quit);
end

--更新包下载完成
function LuaCUpdate.OnPkgFileDownloadComplete()
    if(m_httpDownLoad ~= nil) then
        m_httpDownLoad:Clear();
        m_httpDownLoad = nil;
    end
    m_nCurDownLoadedSize = m_nCurDownLoadedSize + m_www.bytesDownloaded;  --刷新已下载文件大小
    LuaCUIUpdate.UpdateProgressBar(m_nCurDownLoadedSize / m_nTotalDownloadSize); --刷新进度

    local strTempFileUrl = UnityEngine.Application.persistentDataPath .. "/tempFile.bytes";
    local strTargetDir = UnityEngine.Application.persistentDataPath;
    CLuaFunction.UnpackUpdateFile(strTempFileUrl, strTargetDir);

    --解压完，删除临时文件
    if (CLuaFunction.FileExists(strTempFileUrl)) then
        CLuaFunction.DeleteFile(strTempFileUrl);
    end

    --下载完成
    this.DownLoadComplete();
end

--请求下载列表
function LuaCUpdate.RequestDownLoadList()
    coroutine.start(LuaCUpdate.OnRequestDownLoadList);
end
--请求更新列表(单个文件更新)
function LuaCUpdate.OnRequestDownLoadList()
    local url = "http://" .. m_updateUrl .. "/upgrade/single/downloadList_" .. m_nCurVer .. ".txt?p=" .. math.random(1, 100000000);
    log("请求单个文件列表:" .. url);
    m_www = UnityEngine.WWW(url);
    coroutine.www(m_www);

    if(m_www.error == nil) then
        local strInfo = CLuaFunction.ConvertBytesToString(m_www.bytes);
        local arrStr = LuaCommonMethod.Split(strInfo, "\n");
        m_downLoadList = {};
        m_nVerAfterCurUpdate = tonumber(arrStr[1]);
        if(#arrStr > 1) then
            for i = 2, #arrStr do
                local strFileName = arrStr[i];
                if(strFileName ~= nil and strFileName ~= "") then
                    if(this.GetIndexFromTable(strFileName, arrStr) > 0) then
                        table.insert(m_downLoadList, strFileName);
                    end
                end
            end
        end
        this.DownLoadSingleFile();
    else
        log("请求更新列表出错:" .. m_www.error .. ":" .. m_www.url);
        LuaCUIUpdateConfirm.ShowConfirm(this.GetLanguageText("Update_downloadListFail"), "", this.RequestDownLoadList, UnityEngine.Application.Quit);
    end
end

--开始下载单个文件
function LuaCUpdate.DownLoadSingleFile()
    if(#m_downLoadList > 0) then
        --文件没下载完，继续下载
        local strFile = m_downLoadList[1];
        local co = coroutine.create(this.DownLoadingSingleFile);
        coroutine.resume(co, strFile);
    else
        --单个文件都下载完了
        this.DownLoadComplete();
    end
end

function LuaCUpdate.DownLoadingSingleFile(strFileName)
    local url = "http://" .. m_updateUrl .. "/Res/" .. strFileName .. "?p=" .. math.random(1, 100000000);
    log("下载单个文件:" .. url);
    m_www = UnityEngine.WWW(url);
    coroutine.www(m_www);

    while (not m_www.isDone) do
        m_nDownloadingFileSize = m_www.bytesDownloaded;
        coroutine.step();
    end

    if(m_www.error == nil) then
        m_nCurDownLoadedSize = m_nCurDownLoadedSize + m_www.bytesDownloaded;  --刷新已下载文件大小

        --下载完成直接覆盖本地文件
        local strFileUrl = UnityEngine.Application.persistentDataPath .. "/" .. strFileName;

        --先创建文件夹
        local folderUrl = CLuaFunction.GetDirectoryName(strFileUrl);
        if (not CLuaFunction.DirectoryExists(folderUrl)) then
            CLuaFunction.CreateDirectory(folderUrl);
        end

        CLuaFunction.WriteBytesByFileStream(strFileUrl, m_www.bytes);
        table.insert(m_dowmCompleteFileList, strFileName);

        this.SaveUpdateProgressData();
    else
        log("请求单个文件出错:" .. m_www.error .. ":" .. m_www.url);
        LuaCUIUpdateConfirm.ShowConfirm(this.GetLanguageText("Update_downLoadFileFail"), "", this.DownLoadSingleFile, UnityEngine.Application.Quit);
    end

    coroutine.step();
    table.remove(m_downLoadList, 1);
    this.DownLoadSingleFile();
end

--更新文件下载完成
function LuaCUpdate.DownLoadComplete()
    local type = m_arrUpdateType[m_nCurVer];
    if (type == EnumUpdateType_Package) then
        m_nCurPkgVer = m_nCurPkgVer + 1;
        m_nCurVer = m_nCurVer + 1;
    else
        m_nCurVer = m_nVerAfterCurUpdate;
    end
    this.SaveVerData();

    if (m_nCurVer ~= m_nToVer) then --还不是最新版本
        this.RequestDownLoadList(); --请求当前版本的更新文件列表
    else
        this.Finish();  --更新完成
    end
end

--保存当前下载更新进度数据
function LuaCUpdate.SaveUpdateProgressData()
    local fileName = this.ProgressDataUrl();
    local strInfo = m_nToVer .. "," .. m_nCurDownLoadedSize;
    for i, strFileName in ipairs(m_dowmCompleteFileList) do
        strInfo = strInfo .. "\n" .. strFileName;
    end
    CLuaFunction.WriteAllText(fileName, strInfo);
end

--保存版本数据
function LuaCUpdate.ProgressDataUrl()
    local fileName = UnityEngine.Application.persistentDataPath .. "/.ver";
    local strInfo = m_nCurVer .. "|" .. m_nCurPkgVer;
    CLuaFunction.WriteAllText(fileName, strInfo);
end

--保存版本数据
function LuaCUpdate.SaveVerData()
    local fileName = UnityEngine.Application.persistentDataPath .. "/.ver";
    local strInfo = m_nCurVer .. "|" .. m_nCurPkgVer;
    CLuaFunction.WriteAllText(fileName, strInfo);
end

--更新完成
function LuaCUpdate.Finish()
    log("更新完成");
    local fileName = this.ProgressDataUrl();
    if (CLuaFunction.FileExists(fileName)) then
        CLuaFunction.DeleteFile(fileName);
    end

    if (m_httpDownLoad ~= nil) then
        m_httpDownLoad:Destroy();
        m_httpDownLoad = nil;
    end

    LuaGame.RemovePerFrameFunc("LuaCUpdate.Update", LuaCUpdate.Update);
    --LuaCUIUpdate.HideUI();
    LuaGame.Init();
end

--本地存储更新下载进度数据的路径
function LuaCUpdate.ProgressDataUrl()
    return UnityEngine.Application.persistentDataPath .. "/updateProgressData";
end

function LuaCUpdate.GetIndexFromTable(data, array)
    for i, value in ipairs(array) do
        if(value == data) then
            return i;
        end
    end
    return -1;
end

function LuaCUpdate.Update()
    if(m_httpDownLoad ~= nil) then
        if(m_httpDownLoad.isDone) then
            this.OnPkgFileDownloadComplete();
        else
            m_nDownloadingFileSize = m_httpDownLoad.m_nDownLoadBytes;    --刷新已下载文件大小
        end
    end

    this.UpdateDownloadSpeed(); --刷新下载速度

    if (m_nTotalDownloadSize > 0) then
        LuaCUIUpdate.UpdateProgressBar((m_nCurDownLoadedSize + m_nDownloadingFileSize) / m_nTotalDownloadSize);
    end

    if(this.m_bDownloadException) then    --下载异常
        this.m_bDownloadException = false;
        this.OnDownloadPkgFileError();
    end
end

--刷新下载速度
function LuaCUpdate.UpdateDownloadSpeed()
    local fCurTime = UnityEngine.Time.time;
    if (fCurTime - m_fLastTime < m_fCalcSpeedInterval) then
        return;
    end
    if ((m_nCurDownLoadedSize + m_nDownloadingFileSize) - m_nLastDownLoadSize < 0) then
        return;
    end

    --在时间段内下载了多少KB资源
    local strSpeed = "";
    local fDownLoadKb = ((m_nCurDownLoadedSize + m_nDownloadingFileSize) - m_nLastDownLoadSize) / 1024;

    local fSpeed = (fDownLoadKb) / (fCurTime - m_fLastTime);
    if (fSpeed > 1024) then --下载速度超过1M/s
        strSpeed = string.format("%0.2f", (fSpeed / 1024)) .. "M/s";  --保留2位小数
    else
        strSpeed = string.format("%0.2f", (fSpeed / 1024)) .. "KB/s"; --保留2位小数
    end

    m_fLastTime = fCurTime;
    LuaCUIUpdate.UpdateSpeed(strSpeed);
    m_nLastDownLoadSize = m_nCurDownLoadedSize + m_nDownloadingFileSize;
end